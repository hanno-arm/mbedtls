/* BEGIN_HEADER */
#include <mbedtls/ssl.h>
#include <mbedtls/ssl_internal.h>

void ssl_transform_init( mbedtls_ssl_transform *transform );
int ssl_encrypt_buf( mbedtls_ssl_context *ssl,
                     mbedtls_ssl_transform *transform,
                     mbedtls_mps_record *rec,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng );
int ssl_decrypt_buf( mbedtls_ssl_context *ssl,
                     mbedtls_ssl_transform *transform,
                     mbedtls_mps_record *rec );
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_SSL_TLS_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE depends_on:MBEDTLS_SSL_DTLS_ANTI_REPLAY */
void ssl_dtls_replay( char *prevs, char *new, int ret )
{
    mbedtls_ssl_context ssl;
    mbedtls_ssl_config conf;
    char *end_prevs = prevs + strlen( prevs ) + 1;

    mbedtls_ssl_init( &ssl );
    mbedtls_ssl_config_init( &conf );

    TEST_ASSERT( mbedtls_ssl_config_defaults( &conf,
                 MBEDTLS_SSL_IS_CLIENT,
                 MBEDTLS_SSL_TRANSPORT_DATAGRAM,
                 MBEDTLS_SSL_PRESET_DEFAULT ) == 0 );
    TEST_ASSERT( mbedtls_ssl_setup( &ssl, &conf ) == 0 );

    /* Read previous record numbers */
    for( ; end_prevs - prevs >= 13; prevs += 13 )
    {
        prevs[12] = '\0';
        unhexify( ssl.in_ctr + 2, prevs );
        mbedtls_ssl_dtls_replay_update( &ssl );
    }

    /* Check new number */
    unhexify( ssl.in_ctr + 2, new );
    TEST_ASSERT( mbedtls_ssl_dtls_replay_check( &ssl ) == ret );

    mbedtls_ssl_free( &ssl );
    mbedtls_ssl_config_free( &conf );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_X509_CRT_PARSE_C */
void ssl_set_hostname_twice( char *hostname0, char *hostname1 )
{
    mbedtls_ssl_context ssl;
    mbedtls_ssl_init( &ssl );

    TEST_ASSERT( mbedtls_ssl_set_hostname( &ssl, hostname0 ) == 0 );
    TEST_ASSERT( mbedtls_ssl_set_hostname( &ssl, hostname1 ) == 0 );

    mbedtls_ssl_free( &ssl );
}
/* END_CASE */

/* BEGIN_CASE */
void ssl_crypt_record( int cipher_type, int hash_id,
                       int etm, int tag_mode, int ver )
{
    int num_records = 3;
    mbedtls_ssl_context ssl; /* ONLY for debugging */

    mbedtls_ssl_transform t_in, t_out;
    unsigned char *buf;
    size_t const buflen = 16384;
    mbedtls_mps_record rec, rec_backup;
    mbedtls_cipher_info_t const *cipher_info;
    mbedtls_md_info_t const *md_info;

    size_t keylen, maclen, ivlen;
    unsigned char *key0, *key1, *md0, *md1;
    unsigned char iv_enc[16], iv_dec[16];

    /* Initialization */
    mbedtls_ssl_init( &ssl );
    memset( &rec, 0, sizeof( mbedtls_mps_record ) );
    TEST_ASSERT( ( buf = malloc( buflen ) ) != NULL );
    ssl_transform_init( &t_in );
    ssl_transform_init( &t_out );

    /* Pick cipher */
    cipher_info = mbedtls_cipher_info_from_type( cipher_type );
    TEST_ASSERT( cipher_info != NULL );
    TEST_ASSERT( cipher_info->iv_size <= 16 );
    TEST_ASSERT( cipher_info->key_bitlen % 8 == 0 );
    keylen = cipher_info->key_bitlen / 8;
    TEST_ASSERT( ( key0 = malloc( keylen ) ) != NULL );
    TEST_ASSERT( ( key1 = malloc( keylen ) ) != NULL );
    memset( key0, 0x1, keylen );
    memset( key1, 0x2, keylen );

    /* Fill IV buffers (regardless of whether they
     * are being used by the transform). */
    ivlen = cipher_info->iv_size;
    memset( iv_enc, 0x3, sizeof( iv_enc ) );
    memset( iv_dec, 0x4, sizeof( iv_dec ) );

    /* Pick hash function */
    md_info = mbedtls_md_info_from_type( hash_id );
    TEST_ASSERT( md_info != NULL );
    maclen = mbedtls_md_get_size( md_info );
    TEST_ASSERT( ( md0 = malloc( maclen ) ) != NULL );
    TEST_ASSERT( ( md1 = malloc( maclen ) ) != NULL );
    memset( md0, 0x5, maclen );
    memset( md1, 0x6, maclen );

    /* Setup transforms */

    t_out.encrypt_then_mac = etm;
    t_in.encrypt_then_mac = etm;
    t_out.minor_ver = ver;
    t_in.minor_ver = ver;

    t_out.ivlen = ivlen; /* redundant, must be iv size */
    t_in.ivlen = ivlen;  /* redundant, must be iv size */

    switch( cipher_info->mode )
    {
        case MBEDTLS_MODE_GCM:
        case MBEDTLS_MODE_CCM:
            t_out.fixed_ivlen = 4; /* redundant, must be 4 for AEAD */
            t_in.fixed_ivlen = 4;  /* redundant, must be 4 for AEAD */
            t_out.maclen = 0;
            t_in.maclen = 0;
            switch( tag_mode )
            {
                case 0: /* Full tag */
                    t_out.taglen = 16;
                    t_in.taglen = 16;
                    break;

                case 1: /* Partial tag */
                    t_out.taglen = 8;
                    t_in.taglen = 8;
                    break;

                default:
                    TEST_ASSERT( 0 );
                    break;
            }
            break;

        case MBEDTLS_MODE_STREAM:
        case MBEDTLS_MODE_CBC:
            t_out.fixed_ivlen = 0;
            t_in.fixed_ivlen = 0;
            t_out.taglen = 0;
            t_in.taglen = 0;
            switch( tag_mode )
            {
                case 0: /* Full tag */
                    t_out.maclen = maclen;
                    t_in.maclen = maclen;
                    break;

                case 1: /* Partial tag */
                    t_out.maclen = maclen / 2;
                    t_in.maclen = maclen / 2;
                    break;

                default:
                    TEST_ASSERT( 0 );
                    break;
            }
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    memcpy( &t_in.iv_dec, iv_dec, sizeof( iv_dec ) );
    memcpy( &t_in.iv_enc, iv_enc, sizeof( iv_enc ) );
    memcpy( &t_out.iv_dec, iv_enc, sizeof( iv_enc ) );
    memcpy( &t_out.iv_enc, iv_dec, sizeof( iv_dec ) );

    if( cipher_info->mode == MBEDTLS_MODE_CBC ||
        cipher_info->mode == MBEDTLS_MODE_STREAM )
    {
        TEST_ASSERT( mbedtls_md_setup( &t_out.md_ctx_enc, md_info, 1 ) == 0 );
        TEST_ASSERT( mbedtls_md_setup( &t_out.md_ctx_dec, md_info, 1 ) == 0 );
        TEST_ASSERT( mbedtls_md_setup( &t_in.md_ctx_enc,  md_info, 1 ) == 0 );
        TEST_ASSERT( mbedtls_md_setup( &t_in.md_ctx_dec,  md_info, 1 ) == 0 );

        if( ver > MBEDTLS_SSL_MINOR_VERSION_0 )
        {
            TEST_ASSERT( mbedtls_md_hmac_starts( &t_in.md_ctx_enc,
                                                 md0, maclen ) == 0 );
            TEST_ASSERT( mbedtls_md_hmac_starts( &t_in.md_ctx_dec,
                                                 md1, maclen ) == 0 );
            TEST_ASSERT( mbedtls_md_hmac_starts( &t_out.md_ctx_enc,
                                                 md1, maclen ) == 0 );
            TEST_ASSERT( mbedtls_md_hmac_starts( &t_out.md_ctx_dec,
                                                 md0, maclen ) == 0 );
        }
#if defined(MBEDTLS_SSL_PROTO_SSL3)
        else
        {
            memcpy( &t_in.mac_enc, md0, maclen );
            memcpy( &t_in.mac_dec, md1, maclen );
            memcpy( &t_out.mac_enc, md1, maclen );
            memcpy( &t_out.mac_dec, md0, maclen );
        }
#endif
    }

    TEST_ASSERT( mbedtls_cipher_setup( &t_in.cipher_ctx_enc,
                                       cipher_info ) == 0 );
    TEST_ASSERT( mbedtls_cipher_setup( &t_in.cipher_ctx_dec,
                                       cipher_info ) == 0 );
    TEST_ASSERT( mbedtls_cipher_setup( &t_out.cipher_ctx_enc,
                                       cipher_info ) == 0 );
    TEST_ASSERT( mbedtls_cipher_setup( &t_out.cipher_ctx_dec,
                                       cipher_info ) == 0 );

    if( cipher_info->mode == MBEDTLS_MODE_CBC )
    {
        TEST_ASSERT( mbedtls_cipher_set_padding_mode( &t_in.cipher_ctx_enc,
                                                      MBEDTLS_PADDING_NONE ) == 0 );
        TEST_ASSERT( mbedtls_cipher_set_padding_mode( &t_in.cipher_ctx_dec,
                                                      MBEDTLS_PADDING_NONE ) == 0 );
        TEST_ASSERT( mbedtls_cipher_set_padding_mode( &t_out.cipher_ctx_enc,
                                                      MBEDTLS_PADDING_NONE ) == 0 );
        TEST_ASSERT( mbedtls_cipher_set_padding_mode( &t_out.cipher_ctx_dec,
                                                      MBEDTLS_PADDING_NONE ) == 0 );
    }

    TEST_ASSERT( mbedtls_cipher_setkey( &t_in.cipher_ctx_enc, key0,
                                        keylen << 3, MBEDTLS_ENCRYPT ) == 0 );
    TEST_ASSERT( mbedtls_cipher_setkey( &t_in.cipher_ctx_dec, key1,
                                        keylen << 3, MBEDTLS_DECRYPT ) == 0 );
    TEST_ASSERT( mbedtls_cipher_setkey( &t_out.cipher_ctx_enc, key1,
                                        keylen << 3, MBEDTLS_ENCRYPT ) == 0 );
    TEST_ASSERT( mbedtls_cipher_setkey( &t_out.cipher_ctx_dec, key0,
                                        keylen << 3, MBEDTLS_DECRYPT ) == 0 );

    while( num_records-- > 0 )
    {
        /* Prepare record */
        memset( rec.ctr, 0x1, sizeof( rec.ctr ) );
        /* Type and version don't have an influence on the transformation;
         * the transformation has its own version field that determines
         * its operation. */
        rec.type    = 42;
        rec.ver[0]  = 3;
        rec.ver[1]  = 3;
        rec.buf     = buf;
        rec.buf_len = buflen;
        rec.data_offset = 16;
        rec.data_len = 1237;
        rec.len[0] = (unsigned char)( rec.data_len >> 8 );
        rec.len[1] = (unsigned char)( rec.data_len      );
        memset( rec.buf + rec.data_offset, 42, rec.data_len );
        rec_backup = rec;

        /* Encrypt record with t_out */
        TEST_ASSERT( ssl_encrypt_buf( &ssl, &t_out, &rec,
                                      rnd_std_rand, NULL ) == 0 );

        /* Decrypt record with t_in */
        TEST_ASSERT( ssl_decrypt_buf( &ssl, &t_in, &rec ) == 0 );

        /* Compare results */
        TEST_ASSERT( rec.type == rec_backup.type );
        TEST_ASSERT( memcmp( rec.ctr, rec_backup.ctr, 8 ) == 0 );
        TEST_ASSERT( rec.ver[0] == rec_backup.ver[0] );
        TEST_ASSERT( rec.ver[1] == rec_backup.ver[1] );
        TEST_ASSERT( rec.data_len == rec_backup.data_len );
        TEST_ASSERT( rec.data_offset == rec_backup.data_offset );
        TEST_ASSERT( memcmp( rec.buf + rec.data_offset,
                             rec_backup.buf + rec_backup.data_offset,
                             rec.data_len ) == 0 );
    }

    /* Cleanup */
    mbedtls_ssl_free( &ssl );
    mbedtls_ssl_transform_free( &t_in );
    mbedtls_ssl_transform_free( &t_out );
    free( buf );
    free( key0 );
    free( key1 );
    free( md0 );
    free( md1 );
}
/* END_CASE */
